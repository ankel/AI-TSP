The traveling saleman - an AI approach
----

Binh Tran - AI class Fall 2012 @ PSU

Usage: provide the first command line argument with location of the instance.txt file.

The problem is simple enough, and pretty much well defined by this point. The solution, however, isn't. The problem is NP-hard so to find the most optimal solution is, well, hard. In the past I've work with it a couple of time, from brute force to simple prunning and (fail attempt) dynamic programming. However I've never tried the almost-optimal-solution approach.

As suggested by prof. Bart, there are a couple of different strategies to solve this problem, including local search, genetic algorithm, and ant algorithm. Local search is the quickest to code and give really good solution (optimal solution for a small set, 99% optimal for medium set, both runtime set to be ~5s and ultilize parallelism). The large set local search doesn't work at all, giving 3000+ miles tour even after 3 minutes runing with 100% CPU ultilization on a 3-year-old 4-core Intel i7 CPU. Interestingly, the choice of neigbour doesn't affect the result heavily after a full run (60s) but within a small time frame, swap-2-consecutive-element neighbourhood resulted in a more stable result (less deviation between result) vs swap-any-2-element choice of neighbour.

Genetic algorithm seems to be the most prominent approach initially, since the fitness function is fairly simple, solution can be encode easily and efficiently (but not very effectively, as I later found out). Unfortunately I wasn't able to derive a good reproducting strategy between genes. Simple cross over doesn't work since we need to maintain the uniqueness property of each city. One possible strategy, abeit highly inefficient, is to identify common subset (with permutation) and cross over these subset. So if sequences S1=X-..-X-A1-..-An-X-..-X and S2=X-..-X-B1-..-Bn-X-..-X where X is an arbitral number and (B1-...-Bn) is a permutation of (A1-...-An) then these 2 can be cross over. The common subset with permutation can be found using rolling hash algorithm yielding O(n) time complexity for any 2 pair with fix length subset, but it requires a lot cross-reference within the population and is a major time consuming component (according to Visual Studio profiling tool - 40s run time inclusively for about 200 generations). One possible way to improve is to use a Dictionary structure to store rolling hash, but even with fix length subset of 5, there are 29P5 = 1.4e7(approx.) permutation and at very high size, Dictionary becomes very memory inefficient as it tries to balance between avoiding collision and keeping access time low. Like I said, this is a prominent approach but it probably requires more investigating.

As deadline approaches, I turned to the Ant algorithm. I actually had a hard time trying to understand the "algorithm-in-Englist" section but the code is really clear on what it's doing - a bit less clear on why it's doing what it's doing though. For example I don't fully understand why it update pheromone level after a full tour instead of after each move, or why the pheromone level reset when it's below zero instead of when it's below background level. I can see why the latter point doesn't have a strong effect on the result since the different between zero and background level is fairly small, but by updating the trail after each move, the ants can potentially converge faster. Regardless the code runs fast with very very good result (only 2 miles more than the smallest result posted on the class forum). 

Regarding the output order requirement, for the local search and the genetic algorithm, it's fairly simple to enforce the initial configuration to have 0 at the first and last elements, and to never touch these 2. Output then simply is a matter of compare tour[1] vs tour[tour.length - 1] and reverse the array as necessary. For the ant algorithm, as the ants are initially randomly distributed, the solution needs a bit tweaking. There are a lot of different ways to tweak it to the right format, however I decided to implement an iterator using "yield return" technique, which is a C# specific technique. It's guarantee O(n) run time and O(1) extra storage so it's as good as it can get, and most importantly I had a chance to do something I've only learned about so far.

To do:
- Investigate into the genetic algorithm approach.
- Think of a way to force output format form the begining with ant simulator.